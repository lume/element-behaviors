{"version":3,"file":"global.js","mappings":"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","sources":["webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/webpack/bootstrap","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/webpack/runtime/define property getters","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/webpack/runtime/hasOwnProperty shorthand","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/webpack/runtime/make namespace object","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/../../node_modules/solid-js/dist/solid.js","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/../../node_modules/solid-js/store/dist/store.js","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./src/BehaviorMap.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./src/BehaviorRegistry.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/../custom-attributes/src/CustomAttributeRegistry.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/../custom-attributes/src/index.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./src/CancelablePromise.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./src/Privates.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./src/HasAttribute.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst NOTPENDING = {};\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceFactory = null;\nlet Listener = null;\nlet Pending = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n        owner = Owner,\n        unowned = fn.length === 0,\n        root = unowned && !false ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner: detachedOwner || owner\n  },\n        updateFn = unowned ? fn : () => fn(() => cleanNode(root));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    pending: NOTPENDING,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.pending !== NOTPENDING ? s.pending : s.tValue);else value = value(s.pending !== NOTPENDING ? s.pending : s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(() => {\n    fn ? fn() : untrack(onInvalidate);\n    fn = undefined;\n  }, undefined, false, 0),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(source, fetcher, options) {\n  if (arguments.length === 2) {\n    if (typeof fetcher === \"object\") {\n      options = fetcher;\n      fetcher = source;\n      source = true;\n    }\n  } else if (arguments.length === 1) {\n    fetcher = source;\n    source = true;\n  }\n  options || (options = {});\n  const contexts = new Set(),\n        [value, setValue] = createSignal(options.initialValue),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [loading, setLoading] = createSignal(false),\n        [error, setError] = createSignal();\n  let err = undefined,\n      pr = null,\n      initP = null,\n      id = null,\n      loadedUnderTransition = false,\n      scheduled = false,\n      resolved = (\"initialValue\" in options),\n      dynamic = typeof source === \"function\" && createMemo(source);\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    if (sharedConfig.load) initP = sharedConfig.load(id);\n  }\n  function loadEnd(p, v, e, key) {\n    if (pr === p) {\n      pr = null;\n      resolved = true;\n      if (initP && (p === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = null;\n      setError(err = e);\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          if (!Transition.promises.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n          completeLoad(v);\n        }, false);\n      } else completeLoad(v);\n    }\n    return v;\n  }\n  function completeLoad(v) {\n    batch(() => {\n      setValue(() => v);\n      setLoading(false);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    });\n  }\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = value();\n    if (err) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching && scheduled) return;\n    scheduled = false;\n    setError(err = undefined);\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP || untrack(() => fetcher(lookup, {\n      value: value(),\n      refetching\n    }));\n    if (typeof p !== \"object\" || !(\"then\" in p)) {\n      loadEnd(pr, p);\n      return p;\n    }\n    pr = p;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    batch(() => {\n      setLoading(true);\n      trigger();\n    });\n    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, e, e));\n  }\n  Object.defineProperties(read, {\n    loading: {\n      get() {\n        return loading();\n      }\n    },\n    error: {\n      get() {\n        return error();\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        if (err) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));else load(false);\n  return [read, {\n    refetch: load,\n    mutate: setValue\n  }];\n}\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const key of subs.keys()) if (fn(key, v) !== fn(key, p)) {\n      const l = subs.get(key);\n      for (const c of l.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true, STALE);\n  updateComputation(node);\n  return key => {\n    let listener;\n    if (listener = Listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  if (Pending) return fn();\n  let result;\n  const q = Pending = [];\n  try {\n    result = fn();\n  } finally {\n    Pending = null;\n  }\n  runUpdates(() => {\n    for (let i = 0; i < q.length; i += 1) {\n      const data = q[i];\n      if (data.pending !== NOTPENDING) {\n        const pending = data.pending;\n        data.pending = NOTPENDING;\n        writeSignal(data, pending);\n      }\n    }\n  }, false);\n  return result;\n}\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) ;else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n  try {\n    return runUpdates(fn, true);\n  } finally {\n    Owner = prev;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t = Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true\n      });\n      t.done || (t.done = new Promise(res => t.resolve = res));\n      t.running = true;\n    }\n    batch(fn);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let ctx;\n  return (ctx = lookup(Owner, context.id)) !== undefined ? ctx : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  return createMemo(() => resolveChildren(children()));\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\nfunction enableExternalSource(factory) {\n  if (ExternalSourceFactory) {\n    const oldFactory = ExternalSourceFactory;\n    ExternalSourceFactory = (fn, trigger) => {\n      const oldSource = oldFactory(fn, trigger);\n      const source = factory(x => oldSource.track(x), trigger);\n      return {\n        track: x => source.track(x),\n        dispose() {\n          source.dispose();\n          oldSource.dispose();\n        }\n      };\n    };\n  } else {\n    ExternalSourceFactory = factory;\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {\n    const updates = Updates;\n    Updates = null;\n    !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookUpstream(this);\n    Updates = updates;\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  if (Pending) {\n    if (node.pending === NOTPENDING) Pending.push(node);\n    node.pending = value;\n    return value;\n  }\n  if (node.comparator) {\n    if (Transition && Transition.running && Transition.sources.has(node)) {\n      if (node.comparator(node.tValue, value)) return value;\n    } else if (node.comparator(node.value, value)) return value;\n  }\n  let TransitionRunning = false;\n  if (Transition) {\n    TransitionRunning = Transition.running;\n    if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n      Transition.sources.add(node);\n      node.tValue = value;\n    }\n    if (!TransitionRunning) node.value = value;\n  } else node.value = value;\n  if (node.observers && node.observers.length) {\n    runUpdates(() => {\n      for (let i = 0; i < node.observers.length; i += 1) {\n        const o = node.observers[i];\n        if (TransitionRunning && Transition.disposed.has(o)) continue;\n        if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {\n          if (o.pure) Updates.push(o);else Effects.push(o);\n          if (o.observers) markDownstream(o);\n        }\n        if (TransitionRunning) o.tState = STALE;else o.state = STALE;\n      }\n      if (Updates.length > 10e5) {\n        Updates = [];\n        if (false) ;\n        throw new Error();\n      }\n    }, false);\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        runComputation(node, node.tValue, time);\n      }, false);\n    });\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.observers && node.observers.length) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  if (ExternalSourceFactory) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceFactory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if (!runningTransition && node.state === 0 || runningTransition && node.tState === 0) return;\n  if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (!runningTransition && node.state || runningTransition && node.tState) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n          prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {\n      updateComputation(node);\n    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      lookUpstream(node, ancestors[0]);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!Updates) Effects = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition && Transition.running) {\n    if (Transition.promises.size || Transition.queue.size) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n    const sources = Transition.sources;\n    const disposed = Transition.disposed;\n    res = Transition.resolve;\n    for (const e of Effects) {\n      \"tState\" in e && (e.state = e.tState);\n      delete e.tState;\n    }\n    Transition = null;\n    batch(() => {\n      for (const d of disposed) cleanNode(d);\n      for (const v of sources) {\n        v.value = v.tValue;\n        if (v.owned) {\n          for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n        }\n        if (v.tOwned) v.owned = v.tOwned;\n        delete v.tValue;\n        delete v.tOwned;\n        v.tState = 0;\n      }\n      setTransPending(false);\n    });\n  }\n  if (Effects.length) batch(() => {\n    runEffects(Effects);\n    Effects = null;\n  });else {\n    Effects = null;\n  }\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n          if (!tasks.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) setHydrateContext();\n  const resume = queue.length;\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n  for (i = resume; i < queue.length; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {\n        if (source !== ignore) runTop(source);\n      } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!runningTransition && !o.state || runningTransition && !o.tState) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  for (const f of fns) f(err);\n}\nfunction lookup(owner, key) {\n  return owner ? owner.context && owner.context[key] !== undefined ? owner.context[key] : lookup(owner.owner, key) : undefined;\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id) {\n  return function provider(props) {\n    let res;\n    createComputed(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }));\n    return res;\n  };\n}\n\nfunction observable(input) {\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = typeof observer === 'function' ? observer : observer.next && observer.next.bind(observer);\n      if (!handler) {\n        return {\n          unsubscribe() {}\n        };\n      }\n      const dispose = createRoot(disposer => {\n        createComputed(() => {\n          const v = input();\n          untrack(() => handler(v));\n        });\n        return disposer;\n      });\n      if (getOwner()) onCleanup(dispose);\n      return {\n        unsubscribe() {\n          dispose();\n        }\n      };\n    },\n    [Symbol.observable || \"@@observable\"]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = untrack(() => Comp(props || {}));\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return (s = typeof s === \"function\" ? s() : s) == null ? {} : s;\n}\nfunction mergeProps(...sources) {\n  return new Proxy({\n    get(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        const v = resolveSource(sources[i])[property];\n        if (v !== undefined) return v;\n      }\n    },\n    has(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        if (property in resolveSource(sources[i])) return true;\n      }\n      return false;\n    },\n    keys() {\n      const keys = [];\n      for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n      return [...new Set(keys)];\n    }\n  }, propTraps);\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const res = keys.map(k => {\n    const clone = {};\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n        set() {\n          return true;\n        }\n      });\n    }\n    return clone;\n  });\n  res.push(new Proxy({\n    get(property) {\n      return blocked.has(property) ? undefined : props[property];\n    },\n    has(property) {\n      return blocked.has(property) ? false : property in props;\n    },\n    keys() {\n      return Object.keys(props).filter(k => !blocked.has(k));\n    }\n  }, propTraps));\n  return res;\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      return (strictEqual = typeof child === \"function\" && child.length > 0) ? untrack(() => child(c)) : child;\n    }\n    return props.fallback;\n  });\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) return [i, c, conds[i]];\n    }\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    return (strictEqual = typeof c === \"function\" && c.length > 0) ? untrack(() => c(when)) : c;\n  });\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nconst NoErrors = {};\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn(NoErrors));\n}\nfunction ErrorBoundary(props) {\n  let err = NoErrors;\n  if (sharedConfig.context && sharedConfig.load) {\n    err = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count) || NoErrors;\n  }\n  const [errored, setErrored] = createSignal(err);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(() => {\n    let e;\n    if ((e = errored()) !== NoErrors) {\n      const f = props.fallback;\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored(NoErrors))) : f;\n    }\n    onError(setErrored);\n    return props.children;\n  });\n}\n\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let suspenseSetter, showContent, showFallback;\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) {\n    const [inFallback, setFallback] = createSignal(false);\n    suspenseSetter = setFallback;\n    [showContent, showFallback] = listContext.register(inFallback);\n  }\n  const [registry, setRegistry] = createSignal([]),\n        comp = createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        const [showingContent, showContent] = createSignal(false),\n              [showingFallback, showFallback] = createSignal(false);\n        setRegistry(registry => [...registry, {\n          inFallback,\n          showContent,\n          showFallback\n        }]);\n        return [showingContent, showingFallback];\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n  createComputed(() => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          visibleContent = showContent ? showContent() : true,\n          visibleFallback = showFallback ? showFallback() : true,\n          reg = registry(),\n          reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = reg.every(i => !i.inFallback());\n      suspenseSetter && suspenseSetter(!all);\n      reg.forEach(i => {\n        i.showContent(all && visibleContent);\n        i.showFallback(visibleFallback);\n      });\n      return;\n    }\n    let stop = false;\n    for (let i = 0, len = reg.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = reg[n].inFallback();\n      if (!stop && !s) {\n        reg[n].showContent(visibleContent);\n        reg[n].showFallback(visibleFallback);\n      } else {\n        const next = !stop;\n        if (next && suspenseSetter) suspenseSetter(true);\n        if (!tail || next && tail === \"collapsed\") {\n          reg[n].showFallback(visibleFallback);\n        } else reg[n].showFallback(false);\n        stop = true;\n        reg[n].showContent(next);\n      }\n    }\n    if (!stop && suspenseSetter) suspenseSetter(false);\n  });\n  return comp;\n}\nfunction Suspense(props) {\n  let counter = 0,\n      showContent,\n      showFallback,\n      ctx,\n      p,\n      flicker,\n      error;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  },\n        owner = getOwner();\n  if (sharedConfig.context && sharedConfig.load) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    p = sharedConfig.load(key);\n    if (p) {\n      if (typeof p !== \"object\" || !(\"then\" in p)) p = Promise.resolve(p);\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(err => {\n        if ((error = err) || sharedConfig.done) return set();\n        sharedConfig.gather(key);\n        setHydrateContext(ctx);\n        set();\n        setHydrateContext();\n      });\n    } else if (p === null) sharedConfig.gather(key);\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) [showContent, showFallback] = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return flicker = undefined;\n        }\n        if (ctx && p === undefined) setHydrateContext();\n        const rendered = createMemo(() => props.children);\n        return createMemo(() => {\n          const inFallback = store.inFallback(),\n                visibleContent = showContent ? showContent() : true,\n                visibleFallback = showFallback ? showFallback() : true;\n          dispose && dispose();\n          if ((!inFallback || p !== undefined) && visibleContent) {\n            store.resolved = true;\n            ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered();\n          }\n          if (!visibleFallback) return;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nlet DEV;\n\nexport { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };\n","import { $PROXY, $TRACK, getListener, batch, createSignal } from 'solid-js';\n\nconst $RAW = Symbol(\"store-raw\"),\n      $NODE = Symbol(\"store-node\"),\n      $NAME = Symbol(\"store-name\");\nfunction wrap$1(value, name) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps$1)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);\n    const keys = Object.keys(item),\n          desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getDataNodes(target) {\n  let nodes = target[$NODE];\n  if (!nodes) Object.defineProperty(target, $NODE, {\n    value: nodes = {}\n  });\n  return nodes;\n}\nfunction getDataNode(nodes, property, value) {\n  return nodes[property] || (nodes[property] = createDataNode(value, true));\n}\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE || property === $NAME) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  if (getListener()) {\n    const nodes = getDataNodes(target);\n    (nodes._ || (nodes._ = createDataNode()))();\n  }\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nfunction createDataNode(value, equals) {\n  const [s, set] = createSignal(value, equals ? {\n    internal: true\n  } : {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return s;\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) return trackSelf(target);\n    const nodes = getDataNodes(target);\n    const tracked = nodes[property];\n    let value = tracked ? nodes[property]() : target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getDataNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction setProperty(state, property, value) {\n  if (state[property] === value) return;\n  const prev = state[property];\n  const len = state.length;\n  if (value === undefined) {\n    delete state[property];\n  } else state[property] = value;\n  let nodes = getDataNodes(state),\n      node;\n  if (node = getDataNode(nodes, property, prev)) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) (node = getDataNode(nodes, \"length\", len)) && node.$(state.length);\n  (node = nodes._) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i = 0,\n        len = next.length;\n    for (; i < len; i++) {\n      const value = next[i];\n      if (current[i] !== value) setProperty(current, i, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n      prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n          isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\n\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) return trackSelf(target);\n    const nodes = getDataNodes(target);\n    const tracked = nodes[property];\n    let value = tracked ? nodes[property]() : target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      const isFunction = typeof value === \"function\";\n      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getDataNode(nodes, property, value)();else if (value != null && isFunction && value === Array.prototype[property]) {\n        return (...args) => batch(() => Array.prototype[property].apply(receiver, args));\n      }\n    }\n    return isWrappable(value) ? wrap(value) : value;\n  },\n  set(target, property, value) {\n    batch(() => setProperty(target, property, unwrap(value)));\n    return true;\n  },\n  deleteProperty(target, property) {\n    batch(() => setProperty(target, property, undefined));\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value, name) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n              set = v => batch(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  const wrappedStore = wrap(unwrappedStore);\n  return wrappedStore;\n}\nfunction modifyMutable(state, modifier) {\n  batch(() => modifier(unwrap(state)));\n}\n\nconst $ROOT = Symbol(\"store-root\");\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  if (!isWrappable(target) || !isWrappable(previous) || key && target[key] !== previous[key]) {\n    if (target !== previous) {\n      if (property === $ROOT) return target;\n      setProperty(parent, property, target);\n    }\n    return;\n  }\n  if (Array.isArray(target)) {\n    if (target.length && previous.length && (!merge || key && target[0][key] != null)) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start][key] === target[start][key]); start++) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n            newIndices = new Map();\n      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end][key] === target[newEnd][key]); end--, newEnd--) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const {\n    merge,\n    key = \"id\"\n  } = options,\n        v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    const res = applyState(v, {\n      [$ROOT]: state\n    }, $ROOT, merge, key);\n    return res === undefined ? state : res;\n  };\n}\nconst producers = new WeakMap();\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    let proxy;\n    return isWrappable(value) ? producers.get(value) || (producers.set(value, proxy = new Proxy(value, setterTraps)), proxy) : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return state => {\n    if (isWrappable(state)) {\n      let proxy;\n      if (!(proxy = producers.get(state))) {\n        producers.set(state, proxy = new Proxy(state, setterTraps));\n      }\n      fn(proxy);\n    }\n    return state;\n  };\n}\n\nexport { $RAW, createMutable, createStore, modifyMutable, produce, reconcile, unwrap };\n","import {$TRACK} from 'solid-js'\nimport {createMutable, modifyMutable, reconcile} from 'solid-js/store'\nimport type {PossibleBehaviorInstance} from './BehaviorRegistry.js'\n\n/**\n * A map of behavior names to their defined classes.\n *\n * Reactive in Solid.js.\n */\n\nexport class BehaviorMap extends Map<string, PossibleBehaviorInstance> {\n\t// We make things like element.behaviors.get('some-behavior') reactive (in\n\t// Solid.js), but a DOM-spec'd version of element-behaviors would not have\n\t// this, or it could have reactivity if it gets built into the JavaScript\n\t// language (people are talking about \"signals and effects\")\n\t#reactivityTriggerObject = createMutable<Record<string, PossibleBehaviorInstance>>({})\n\n\tfind(predicate: (name: string, behavior: PossibleBehaviorInstance) => boolean) {\n\t\tlet result: PossibleBehaviorInstance | undefined = void undefined\n\n\t\tfor (const [name, behavior] of this) {\n\t\t\tif (!predicate(name, behavior)) continue\n\t\t\tresult = behavior\n\t\t\tbreak\n\t\t}\n\n\t\treturn result\n\t}\n\n\toverride get(key: string): PossibleBehaviorInstance | undefined {\n\t\t// read, causes tracking in Solid.js effects.\n\t\tthis.#reactivityTriggerObject[key]\n\n\t\treturn super.get(key)\n\t}\n\n\toverride set(key: string, value: PossibleBehaviorInstance): this {\n\t\tqueueMicrotask(() => {\n\t\t\t// write, triggers Solid.js effects\n\t\t\tthis.#reactivityTriggerObject[key] = value\n\t\t})\n\n\t\t// TODO Remove the set() method from end users, allow the user to add\n\t\t// behaviors in a fashion similar to classList.add().\n\t\tsuper.set(key, value)\n\t\treturn this\n\t}\n\n\toverride delete(key: string): boolean {\n\t\tqueueMicrotask(() => {\n\t\t\t// write, triggers Solid.js effects\n\t\t\tdelete this.#reactivityTriggerObject[key]\n\t\t})\n\n\t\treturn super.delete(key)\n\t}\n\n\toverride clear(): void {\n\t\tqueueMicrotask(() => {\n\t\t\t// delete all properties, trigger single Solid.js effect update\n\t\t\tmodifyMutable(this.#reactivityTriggerObject, reconcile({}))\n\t\t})\n\n\t\tsuper.clear()\n\t}\n\n\toverride has(key: string): boolean {\n\t\t// read, causes tracking in Solid.js effects.\n\t\t// (TODO `in` operator not reactive yet, https://github.com/solidjs/solid/issues/1107)\n\t\t// key in this.#reactivityTriggerObject\n\t\t// Workaround, read the property\n\t\tthis.#reactivityTriggerObject[key]\n\n\t\treturn super.has(key)\n\t}\n\n\toverride entries(): IterableIterator<[string, PossibleBehaviorInstance]> {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\treturn super.entries()\n\t}\n\n\toverride [Symbol.iterator](): IterableIterator<[string, PossibleBehaviorInstance]> {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\treturn super[Symbol.iterator]()\n\t}\n\n\toverride forEach(\n\t\tcallbackfn: (value: PossibleBehaviorInstance, key: string, map: Map<string, PossibleBehaviorInstance>) => void,\n\t\tthisArg?: any,\n\t): void {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\tsuper.forEach(callbackfn, thisArg)\n\t}\n\n\toverride keys(): IterableIterator<string> {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\treturn super.keys()\n\t}\n\n\toverride get size(): number {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\treturn super.size\n\t}\n\toverride set size(n: number) {\n\t\t// @ts-expect-error readonly property according to TS, but in JS it is\n\t\t// assignable though nothing happens. We need this so that the property\n\t\t// behaves the same after we override it.\n\t\tsuper.size = n\n\t}\n}\n","import type {Constructor} from 'lowclass'\nimport type {BehaviorMap} from './BehaviorMap.js'\n\n/** A registry of behaviors. Similar to CustomElementRegistry. */\nexport class BehaviorRegistry {\n\t#definedBehaviors = new Map<string, PossibleBehaviorConstructor>()\n\t#whenDefinedPromises: Map<string, {promise: Promise<void>; resolve: () => void}> = new Map()\n\n\t/**\n\t * Associate a class `Behavior` to a given behavior `name`. Any time an\n\t * element has the named behavior, the given class will be instantiated and\n\t * the instance will be able to apply logic to its host element.\n\t */\n\tdefine<T extends PossibleBehaviorConstructor>(name: string, Behavior: T) {\n\t\tif (!this.#definedBehaviors.has(name)) {\n\t\t\tthis.#definedBehaviors.set(name, Behavior)\n\n\t\t\tif (this.#whenDefinedPromises.has(name)) {\n\t\t\t\tthis.#whenDefinedPromises.get(name)!.resolve()\n\t\t\t\tthis.#whenDefinedPromises.delete(name)\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`Behavior ${name} is already defined.`)\n\t\t}\n\t}\n\n\t/** Get the behavior class associated with `name`. */\n\tget(name: string) {\n\t\treturn this.#definedBehaviors.get(name)\n\t}\n\n\t/** Returns `true` if there's a class defined for the given `name`, `false` otherwise. */\n\thas(name: string) {\n\t\treturn this.#definedBehaviors.has(name)\n\t}\n\n\t/**\n\t * Wait for the promise returned by this to run code after a behavior class\n\t * for the given `name` has been defined. If the behavior class is already\n\t * defined, resolves immediately.\n\t */\n\twhenDefined(name: string): Promise<void> {\n\t\tif (this.#whenDefinedPromises.has(name)) return this.#whenDefinedPromises.get(name)!.promise\n\t\tif (this.has(name)) return Promise.resolve()\n\n\t\tlet resolve!: () => void\n\t\tconst promise = new Promise<void>(r => (resolve = r))\n\n\t\tthis.#whenDefinedPromises.set(name, {promise, resolve})\n\n\t\treturn promise\n\t}\n}\n\nexport let elementBehaviors: BehaviorRegistry\n\n// Avoid errors trying to use DOM APIs in non-DOM environments (f.e. server-side rendering).\nif (globalThis.window?.document) {\n\telementBehaviors = globalThis.elementBehaviors = new BehaviorRegistry()\n}\n\ndeclare global {\n\t// const doesn't always work (TS bug). At time of writing this, it doesn't work in this TS playground example:\n\t// https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBAbzgXwFCoCbAMYBsCGUwcA5rhAEb66KpxzYQB2AzvAGYQQBccTArgFsKwKKjSoylagBUAFgEsWAOk4Q4Aeg1wAolCjQANHAXwYipgGsWcAAZrbJm0wjws7BU2AYgA\n\t// And discussions:\n\t// https://discord.com/channels/508357248330760243/508357248330760249/1019034094060978228\n\t// https://discord.com/channels/508357248330760243/1019017621397585961\n\tvar elementBehaviors: BehaviorRegistry\n\n\tinterface Window {\n\t\telementBehaviors: BehaviorRegistry\n\t}\n}\n\nexport type ElementBehaviors = {behaviors: BehaviorMap}\n\nexport type ElementWithBehaviors = Element & ElementBehaviors\n\nexport type PossibleBehaviorConstructor = Constructor<\n\tPossibleBehaviorInstance,\n\t[ElementWithBehaviors],\n\t{awaitElementDefined?: boolean; observedAttributes?: string[]}\n>\n\nexport type PossibleBehaviorInstance = {\n\tconnectedCallback?: (element: Element) => void\n\tdisconnectedCallback?: (element: Element) => void\n\tattributeChangedCallback?: (attr: string, oldValue: string | null, newValue: string | null, element: Element) => void\n\t[k: string]: any\n\t[k: number]: any\n}\n","import type {Constructor} from 'lowclass'\n\nconst forEach = Array.prototype.forEach\n\nexport class CustomAttributeRegistry {\n\tprivate _attrMap = new Map<string, Constructor>()\n\tprivate _elementMap = new WeakMap<Element, Map<string, CustomAttribute>>()\n\n\tprivate _observer: MutationObserver = new MutationObserver(mutations => {\n\t\tforEach.call(mutations, (m: MutationRecord) => {\n\t\t\tif (m.type === 'attributes') {\n\t\t\t\tconst attr = this._getConstructor(m.attributeName!)\n\t\t\t\tif (attr) this._handleChange(m.attributeName!, m.target as Element, m.oldValue)\n\t\t\t}\n\n\t\t\t// chlidList\n\t\t\telse {\n\t\t\t\tforEach.call(m.removedNodes, this._elementDisconnected)\n\t\t\t\tforEach.call(m.addedNodes, this._elementConnected)\n\t\t\t}\n\t\t})\n\t})\n\n\tconstructor(public ownerDocument: Document | ShadowRoot) {\n\t\tif (!ownerDocument) throw new Error('Must be given a document')\n\t}\n\n\tdefine(attrName: string, Class: Constructor) {\n\t\tthis._attrMap.set(attrName, Class)\n\t\tthis._upgradeAttr(attrName)\n\t\tthis._reobserve()\n\t}\n\n\tget(element: Element, attrName: string) {\n\t\tconst map = this._elementMap.get(element)\n\t\tif (!map) return\n\t\treturn map.get(attrName)\n\t}\n\n\tprivate _getConstructor(attrName: string) {\n\t\treturn this._attrMap.get(attrName)\n\t}\n\n\tprivate _observe() {\n\t\tthis._observer.observe(this.ownerDocument, {\n\t\t\tchildList: true,\n\t\t\tsubtree: true,\n\t\t\tattributes: true,\n\t\t\tattributeOldValue: true,\n\t\t\tattributeFilter: Array.from(this._attrMap.keys()),\n\t\t\t// attributeFilter: [...this._attrMap.keys()], // Broken in Oculus\n\t\t\t// attributeFilter: this._attrMap.keys(), // This works in Chrome, but TS complains, and not clear if it should work in all browsers yet: https://github.com/whatwg/dom/issues/1092\n\t\t})\n\t}\n\n\tprivate _unobserve() {\n\t\tthis._observer.disconnect()\n\t}\n\n\tprivate _reobserve() {\n\t\tthis._unobserve()\n\t\tthis._observe()\n\t}\n\n\tprivate _upgradeAttr(attrName: string, node: Element | Document | ShadowRoot = this.ownerDocument) {\n\t\tconst matches = node.querySelectorAll('[' + attrName + ']')\n\n\t\t// Possibly create custom attributes that may be in the given 'node' tree.\n\t\t// Use a forEach as Edge doesn't support for...of on a NodeList\n\t\tforEach.call(matches, (element: Element) => this._handleChange(attrName, element, null))\n\t}\n\n\tprivate _elementConnected = (element: Element) => {\n\t\tif (element.nodeType !== 1) return\n\n\t\t// For each of the connected element's attribute, possibly instantiate the custom attributes.\n\t\t// Use a forEach as Safari 10 doesn't support for...of on NamedNodeMap (attributes)\n\t\tforEach.call(element.attributes, (attr: Attr) => {\n\t\t\tif (this._getConstructor(attr.name)) this._handleChange(attr.name, element, null)\n\t\t})\n\n\t\t// Possibly instantiate custom attributes that may be in the subtree of the connected element.\n\t\tthis._attrMap.forEach((_constructor, attr) => this._upgradeAttr(attr, element))\n\t}\n\n\tprivate _elementDisconnected = (element: Element) => {\n\t\tconst map = this._elementMap.get(element)\n\t\tif (!map) return\n\n\t\tmap.forEach(inst => inst.disconnectedCallback?.(), this)\n\n\t\tthis._elementMap.delete(element)\n\t}\n\n\tprivate _handleChange(attrName: string, el: Element, oldVal: string | null) {\n\t\tlet map = this._elementMap.get(el)\n\t\tif (!map) this._elementMap.set(el, (map = new Map()))\n\n\t\tlet inst = map.get(attrName)\n\t\tconst newVal = el.getAttribute(attrName)\n\n\t\t// Attribute is being created\n\t\tif (!inst) {\n\t\t\tconst Constructor = this._getConstructor(attrName)!\n\t\t\tinst = new Constructor() as CustomAttribute\n\t\t\tmap.set(attrName, inst)\n\t\t\tinst.ownerElement = el\n\t\t\tinst.name = attrName\n\t\t\tif (newVal == null) throw new Error('Not possible!')\n\t\t\tinst.value = newVal\n\t\t\tinst.connectedCallback?.()\n\t\t\treturn\n\t\t}\n\n\t\t// Attribute was removed\n\t\tif (newVal == null) {\n\t\t\tinst.disconnectedCallback?.()\n\t\t\tmap.delete(attrName)\n\t\t}\n\n\t\t// Attribute changed\n\t\telse if (newVal !== inst.value) {\n\t\t\tinst.value = newVal\n\t\t\tif (oldVal == null) throw new Error('Not possible!')\n\t\t\tinst.changedCallback?.(oldVal, newVal)\n\t\t}\n\t}\n}\n\n// TODO Replace with a class that extends from `Attr` for alignment with the web platform?\nexport interface CustomAttribute {\n\townerElement: Element\n\tname: string\n\tvalue: string\n\tconnectedCallback?(): void\n\tdisconnectedCallback?(): void\n\tchangedCallback?(oldValue: string, newValue: string): void\n}\n\n// Avoid errors trying to use DOM APIs in non-DOM environments (f.e. server-side rendering).\nif (globalThis.window?.document) {\n\tconst _attachShadow = Element.prototype.attachShadow\n\n\tElement.prototype.attachShadow = function attachShadow(options) {\n\t\tconst root = _attachShadow.call(this, options)\n\n\t\tif (!root.customAttributes) root.customAttributes = new CustomAttributeRegistry(root)\n\n\t\treturn root\n\t}\n}\n","// TODO We don't know when a ShadowRoot is no longer referenced, hence we cannot\n// unobserve them. Verify that MOs are cleaned up once ShadowRoots are no longer\n// referenced.\n\nimport {CustomAttributeRegistry} from './CustomAttributeRegistry.js'\n\nexport * from './CustomAttributeRegistry.js'\n\nexport let customAttributes: CustomAttributeRegistry\n\n// Avoid errors trying to use DOM APIs in non-DOM environments (f.e. server-side rendering).\nif (globalThis.window?.document) customAttributes = globalThis.customAttributes = new CustomAttributeRegistry(document)\n\ndeclare global {\n\t// const doesn't always work (TS bug). At time of writing this, it doesn't work in this TS playground example:\n\t// https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBAbzgXwFCoCbAMYBsCGUwcA5rhAEb66KpxzYQB2AzvAGYQQBccTArgFsKwKKjSoylagBUAFgEsWAOk4Q4Aeg1wAolCjQANHAXwYipgGsWcAAZrbJm0wjws7BU2AYgA\n\t// And discussions:\n\t// https://discord.com/channels/508357248330760243/508357248330760249/1019034094060978228\n\t// https://discord.com/channels/508357248330760243/1019017621397585961\n\tvar customAttributes: CustomAttributeRegistry\n\n\tinterface ShadowRoot {\n\t\tcustomAttributes: CustomAttributeRegistry\n\t}\n\n\tinterface Window {\n\t\tcustomAttributes: CustomAttributeRegistry\n\t}\n}\n\nexport const version = '0.1.6'\n","import {Privates} from './Privates.js'\n\nexport const _ = Privates()\n\nexport interface CancelablePromiseOptions {\n\trejectOnCancel?: boolean\n}\n\nexport class PromiseCancellation extends Error {}\n\nexport class CancelablePromise<T> extends Promise<T> {\n\tcanceled: boolean\n\n\tconstructor(\n\t\texecutor: Promise<T> | ((resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void),\n\t\toptions: CancelablePromiseOptions,\n\t) {\n\t\tconst rejectOnCancel = options ? options.rejectOnCancel : false\n\t\tlet originalReject\n\n\t\t// if the first arg is a promise-like\n\t\tif (executor instanceof Promise) {\n\t\t\tconst promise = executor\n\n\t\t\tsuper((resolve, reject) => {\n\t\t\t\toriginalReject = reject\n\n\t\t\t\tpromise\n\t\t\t\t\t.then(value => {\n\t\t\t\t\t\tif (this.canceled) return\n\t\t\t\t\t\tresolve(value)\n\t\t\t\t\t})\n\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\tif (this.canceled) return\n\t\t\t\t\t\treject(error)\n\t\t\t\t\t})\n\t\t\t})\n\t\t} else {\n\t\t\tsuper((resolve, reject) => {\n\t\t\t\toriginalReject = reject\n\t\t\t\texecutor(\n\t\t\t\t\tvalue => {\n\t\t\t\t\t\tif (this.canceled) return\n\t\t\t\t\t\tresolve(value)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\tif (this.canceled) return\n\t\t\t\t\t\treject(error)\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\n\t\tthis.canceled = false\n\t\t_(this).originalReject = originalReject\n\t\t_(this).rejectOnCancel = rejectOnCancel\n\t}\n\n\tcancel() {\n\t\tthis.canceled = true\n\n\t\tif (_(this).rejectOnCancel) {\n\t\t\t_(this).originalReject(new PromiseCancellation('canceled'))\n\t\t}\n\t}\n}\n","// TODO safe types for privates\nexport function Privates() {\n\tconst storage = new WeakMap()\n\n\treturn (obj: object) => {\n\t\tlet privates = storage.get(obj)\n\t\tif (!privates) storage.set(obj, (privates = {}))\n\t\treturn privates\n\t}\n}\n","import '@lume/custom-attributes/dist/index.js' // polyfills global Custom Attributes API\nimport type {CustomAttribute} from '@lume/custom-attributes/dist/index.js'\nimport {CancelablePromise, PromiseCancellation} from './CancelablePromise.js'\nimport type {ElementWithBehaviors, PossibleBehaviorConstructor, PossibleBehaviorInstance} from './BehaviorRegistry.js'\nimport {BehaviorMap} from './BehaviorMap.js'\n\n/**\n * Defines the global `has=\"\"` attribute for assigning behaviors to an element.\n *\n * One instance of this class is instantiated per element with `has=\"\"` attribute.\n *\n * If you're using element-behaviors, then all elements now also have a\n * `behaviors` property that is a map of behavior names to behavior instances.\n */\nexport class HasAttribute implements CustomAttribute {\n\t// Properties defined by CustomAttribute\n\t// TODO Ensure these types from from CustomAttribute\n\tdeclare ownerElement: ElementWithBehaviors\n\tdeclare value: string\n\tdeclare name: string\n\n\tget behaviors() {\n\t\treturn this.ownerElement.behaviors\n\t}\n\n\tobservers = new Map<PossibleBehaviorInstance, MutationObserver>()\n\telementDefinedPromises = new Map<string, CancelablePromise<CustomElementConstructor>>()\n\n\tisConnected = false // TODO move to base class\n\n\t// TODO an improvement would be that behaviors are instantiated on element\n\t// construction, though that will add some complexity (probably patching of\n\t// many native APIs). Probably needs a change in custom-attributes first so it\n\t// handles attributes during element construction.\n\tconnectedCallback() {\n\t\tthis.isConnected = true\n\t\tthis.changedCallback('', this.value)\n\t}\n\n\tdisconnectedCallback() {\n\t\tthis.isConnected = false\n\t\tthis.#skipConnectedCheck = true\n\t\tthis.changedCallback(this.value, '')\n\t\tthis.#skipConnectedCheck = false\n\t}\n\n\t#skipConnectedCheck = false\n\n\tchangedCallback(oldVal: string, newVal: string) {\n\t\tif (!this.#skipConnectedCheck) {\n\t\t\tif (!this.isConnected) return\n\t\t}\n\n\t\tconst currentBehaviors = this.getBehaviorNames(newVal)\n\t\tconst previousBehaviors = this.getBehaviorNames(oldVal)\n\n\t\t// small optimization: if no previous or new behaviors, just quit\n\t\t// early. It would still function the same without this.\n\t\tif (currentBehaviors.length == 0 && previousBehaviors.length == 0) return\n\n\t\tconst {removed, added} = this.getDiff(previousBehaviors, currentBehaviors)\n\t\tthis.handleDiff(removed, added)\n\t}\n\n\tprivate getBehaviorNames(string: string) {\n\t\tif (string.trim() == '') return []\n\t\telse return string.split(/\\s+/)\n\t}\n\n\tprivate getDiff(previousBehaviors: string[], currentBehaviors: string[]) {\n\t\tconst diff = {\n\t\t\tremoved: [] as string[],\n\t\t\tadded: currentBehaviors,\n\t\t}\n\n\t\tfor (let i = 0, l = previousBehaviors.length; i < l; i += 1) {\n\t\t\tconst oldBehavior = previousBehaviors[i]\n\n\t\t\t// if it exists in the previousBehaviors but not the newBehaviors, then\n\t\t\t// the node was removed.\n\t\t\tif (!diff.added.includes(oldBehavior)) {\n\t\t\t\tdiff.removed.push(oldBehavior)\n\t\t\t}\n\n\t\t\t// otherwise the old value also exists in the set of new values, so\n\t\t\t// therefore it wasn't added or removed, so let's remove it so we\n\t\t\t// don't count it as added\n\t\t\telse {\n\t\t\t\tdiff.added.splice(diff.added.indexOf(oldBehavior), 1)\n\t\t\t}\n\t\t}\n\n\t\treturn diff\n\t}\n\n\tprivate handleDiff(removed: string[], added: string[]) {\n\t\tfor (const name of removed) this.disconnectBehavior(name)\n\t\tfor (const name of added) this.connectBehavior(name)\n\t}\n\n\tprivate async connectBehavior(name: string) {\n\t\tlet Behavior = elementBehaviors.get(name)\n\n\t\tif (!Behavior) {\n\t\t\tawait elementBehaviors.whenDefined(name)\n\t\t\tBehavior = elementBehaviors.get(name)!\n\t\t}\n\n\t\t// TODO Read observedAttributes during the define() call instead, like\n\t\t// custom elements.\n\t\tconst observedAttributes = Behavior.observedAttributes\n\n\t\tconst tagName = this.ownerElement.tagName\n\n\t\ttry {\n\t\t\t// if the element is a custom element and the behavior specifies to wait for it to be defined\n\t\t\tif (Behavior.awaitElementDefined && tagName.includes('-') && !customElements.get(tagName.toLowerCase())) {\n\t\t\t\tconst promiseId = name + '_' + tagName\n\t\t\t\tlet promise = this.elementDefinedPromises.get(promiseId)\n\n\t\t\t\tif (!promise) {\n\t\t\t\t\tpromise = new CancelablePromise(customElements.whenDefined(tagName.toLowerCase()), {\n\t\t\t\t\t\trejectOnCancel: true,\n\t\t\t\t\t})\n\t\t\t\t\tthis.elementDefinedPromises.set(promiseId, promise)\n\t\t\t\t}\n\n\t\t\t\tawait promise\n\t\t\t\tthis.elementDefinedPromises.delete(promiseId)\n\t\t\t}\n\n\t\t\tif (this.isConnected) {\n\t\t\t\tconst behavior = new Behavior(this.ownerElement)\n\t\t\t\tthis.behaviors.set(name, behavior)\n\t\t\t\tbehavior.connectedCallback?.(this.ownerElement)\n\n\t\t\t\tif (Array.isArray(observedAttributes) && observedAttributes.length) {\n\t\t\t\t\tthis.fireInitialAttributeChangedCallbacks(behavior, observedAttributes)\n\t\t\t\t\tthis.createAttributeObserver(behavior)\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (!(e instanceof PromiseCancellation)) throw e\n\n\t\t\t// do nothing if promise canceled\n\t\t}\n\t}\n\n\tprivate disconnectBehavior(name: string) {\n\t\tconst promiseId = name + '_' + this.ownerElement.tagName\n\t\tconst promise = this.elementDefinedPromises.get(promiseId)\n\n\t\tif (promise) {\n\t\t\tpromise.cancel()\n\t\t\tthis.elementDefinedPromises.delete(promiseId)\n\t\t}\n\n\t\tconst behavior = this.behaviors.get(name)\n\n\t\t// There will only be a behavior if connectBehavior both created it and\n\t\t// ran its connectedCallback.\n\t\tif (!behavior) return\n\n\t\tbehavior.disconnectedCallback?.(this.ownerElement)\n\t\tthis.destroyAttributeObserver(behavior)\n\t\tthis.behaviors.delete(name)\n\t}\n\n\tdestroyAttributeObserver(behavior: PossibleBehaviorInstance) {\n\t\tconst observer = this.observers.get(behavior)\n\t\tif (!observer) return\n\t\tobserver.disconnect()\n\t\tthis.observers.delete(behavior)\n\t}\n\n\t// Behaviors observe attribute changes, implemented with MutationObserver\n\t//\n\t// We have to create one observer per behavior because otherwise\n\t// MutationObserver doesn't have an API for disconnecting from a single\n\t// element, only for disconnecting from all elements.\n\tcreateAttributeObserver(behavior: PossibleBehaviorInstance) {\n\t\tconst el = this.ownerElement\n\n\t\tconst observer = new MutationObserver(records => {\n\t\t\tif (!behavior.attributeChangedCallback) return\n\n\t\t\t// Because we get mutations in order, and we have all the attribute\n\t\t\t// values for a given attribute along the way while iterating on\n\t\t\t// mutation records, we keep track of previous and current attribute\n\t\t\t// values (per attribute name) with this variable and thus we can\n\t\t\t// fire behavior.attributeChangedCallback with each previous and\n\t\t\t// current value. For why we need to do this, see\n\t\t\t// https://stackoverflow.com/questions/60593551.\n\t\t\tlet lastAttributeValues: {[k: string]: string | null} = {}\n\n\t\t\tlet name = ''\n\n\t\t\tfor (const record of records) {\n\t\t\t\tif (record.type !== 'attributes') continue\n\n\t\t\t\tname = record.attributeName!\n\n\t\t\t\tif (lastAttributeValues[name] === undefined) {\n\t\t\t\t\tlastAttributeValues[name] = record.oldValue\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tbehavior.attributeChangedCallback(name, lastAttributeValues[name], record.oldValue, this.ownerElement)\n\n\t\t\t\tlastAttributeValues[name] = record.oldValue\n\t\t\t}\n\n\t\t\tlet attr: Attr | null\n\n\t\t\tfor (const name in lastAttributeValues) {\n\t\t\t\tattr = el.attributes.getNamedItem(name)\n\t\t\t\tbehavior.attributeChangedCallback(\n\t\t\t\t\tname,\n\t\t\t\t\tlastAttributeValues[name],\n\t\t\t\t\tattr === null ? null : attr.value,\n\t\t\t\t\tthis.ownerElement,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\n\t\tobserver.observe(el, {\n\t\t\tattributes: true,\n\t\t\tattributeOldValue: true,\n\t\t\tattributeFilter: (behavior.constructor as PossibleBehaviorConstructor).observedAttributes,\n\t\t})\n\n\t\tthis.observers.set(behavior, observer)\n\t}\n\n\tfireInitialAttributeChangedCallbacks(behavior: PossibleBehaviorInstance, attributes: string[]) {\n\t\tif (!behavior.attributeChangedCallback) return\n\n\t\tfor (const name of attributes) {\n\t\t\tif (this.ownerElement.hasAttribute(name))\n\t\t\t\tbehavior.attributeChangedCallback(\n\t\t\t\t\tname,\n\t\t\t\t\tnull,\n\t\t\t\t\tthis.ownerElement.attributes.getNamedItem(name)!.value,\n\t\t\t\t\tthis.ownerElement,\n\t\t\t\t)\n\t\t}\n\t}\n}\n\n// Avoid errors trying to use DOM APIs in non-DOM environments (f.e. server-side rendering).\nif (globalThis.window?.document) {\n\t// stores the behaviors associated to each element.\n\tconst behaviorMaps = new WeakMap<object, BehaviorMap>()\n\n\tObject.defineProperty(Element.prototype, 'behaviors', {\n\t\tget() {\n\t\t\tlet behaviorMap: BehaviorMap | null = null\n\n\t\t\tif (behaviorMaps.has(this)) {\n\t\t\t\tbehaviorMap = behaviorMaps.get(this)!\n\t\t\t} else {\n\t\t\t\tbehaviorMaps.set(this, (behaviorMap = new BehaviorMap()))\n\t\t\t}\n\n\t\t\treturn behaviorMap\n\t\t},\n\t})\n\n\tconst _attachShadow = Element.prototype.attachShadow\n\n\tElement.prototype.attachShadow = function (options) {\n\t\tconst root = _attachShadow.call(this, options)\n\n\t\troot.customAttributes.define('has', HasAttribute)\n\n\t\treturn root\n\t}\n\n\tglobalThis.customAttributes.define('has', HasAttribute)\n}\n","// TODO: element behaviors currently don't work on elements when they are\n// defined (via elementBehaviors.define()) after the elements are already in the\n// DOM. Make it order-independent.\n\nexport * from './BehaviorMap.js'\nexport * from './BehaviorRegistry.js'\nexport * from './HasAttribute.js'\n\n// Leave this last line alone, it gets automatically updated when publishing a\n// new version of this package.\nexport const version = '3.1.0'\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","$PROXY","$TRACK","signalOptions","equals","a","b","ERROR","runEffects","runQueue","NOTPENDING","STALE","PENDING","UNOWNED","owned","cleanups","context","owner","transPending","setTransPending","createSignal","Owner","SuspenseContext","Transition","Scheduler","ExternalSourceFactory","Listener","Pending","Updates","Effects","ExecCount","options","assign","s","observers","observerSlots","pending","comparator","undefined","readSignal","bind","running","sources","has","tValue","writeSignal","createMemo","fn","c","createComputation","tState","push","updateComputation","result","q","runUpdates","i","length","data","untrack","listener","getListener","children","resolveChildren","runningTransition","this","state","updates","lookUpstream","sSlot","sourceSlots","node","isComp","TransitionRunning","add","disposed","pure","markDownstream","Error","cleanNode","time","runComputation","queueMicrotask","nextValue","err","handleError","updatedAt","init","tOwned","track","trigger","ordinary","onCleanup","dispose","triggerInTransition","done","l","Promise","resolve","then","t","Set","effects","promises","queue","res","startTransition","inTransition","x","runTop","suspense","inFallback","ancestors","top","prev","wait","item","tasks","delete","size","apply","scheduleQueue","e","d","v","len","completeUpdates","ignore","source","pop","index","obs","n","fns","lookup","f","Array","isArray","results","createProvider","id","props","createComputed","defaultValue","createContext","$RAW","$NODE","$NAME","isWrappable","proto","getPrototypeOf","unwrap","set","unwrapped","isFrozen","slice","keys","desc","getOwnPropertyDescriptors","getDataNodes","target","nodes","getDataNode","property","createDataNode","trackSelf","_","internal","$","setProperty","proxyTraps","receiver","tracked","getOwnPropertyDescriptor","isFunction","args","wrap","deleteProperty","ownKeys","Reflect","configurable","writable","name","p","Proxy","og","$ROOT","applyState","parent","merge","previous","j","start","end","newEnd","newIndicesNext","keyVal","Math","min","temp","newIndices","Map","targetKeys","previousKeys","reconcile","WeakMap","BehaviorMap","find","predicate","behavior","super","clear","modifier","entries","iterator","forEach","callbackfn","thisArg","BehaviorRegistry","define","Behavior","whenDefined","promise","r","globalThis","window","document","elementBehaviors","CustomAttributeRegistry","constructor","ownerDocument","_attrMap","_elementMap","_observer","MutationObserver","mutations","m","type","_getConstructor","attributeName","_handleChange","oldValue","removedNodes","_elementDisconnected","addedNodes","_elementConnected","element","nodeType","attributes","attr","_constructor","_upgradeAttr","map","inst","disconnectedCallback","attrName","Class","_reobserve","_observe","observe","childList","subtree","attributeOldValue","attributeFilter","from","_unobserve","disconnect","matches","querySelectorAll","el","oldVal","newVal","getAttribute","ownerElement","connectedCallback","changedCallback","_attachShadow","Element","attachShadow","root","customAttributes","storage","privates","Privates","PromiseCancellation","CancelablePromise","executor","rejectOnCancel","originalReject","reject","canceled","catch","error","cancel","HasAttribute","elementDefinedPromises","isConnected","behaviors","currentBehaviors","getBehaviorNames","previousBehaviors","removed","added","getDiff","handleDiff","string","trim","split","diff","oldBehavior","includes","splice","indexOf","disconnectBehavior","connectBehavior","observedAttributes","tagName","awaitElementDefined","customElements","toLowerCase","promiseId","fireInitialAttributeChangedCallbacks","createAttributeObserver","destroyAttributeObserver","observer","records","attributeChangedCallback","lastAttributeValues","record","getNamedItem","hasAttribute","behaviorMaps","behaviorMap"],"sourceRoot":""}